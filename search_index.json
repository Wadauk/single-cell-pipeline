[
["index.html", "前言", " 前言 在这本书，我将介绍单细胞转录组分析流程。在这里要感谢大神的帮助，让我在短短时间完成流程的学习，我将通过知识分享的方式，进一步加深对单细胞转录组分析流程的细节理解。 2019年2月12日是本书起笔的日子，也是大神离开实验室的日子。大神现在坐在我的右边，非常珍惜和大神面对面相处的最后一小时。大神已经成为教授，建立了自己的实验室，希望一切顺利，再创辉煌。 "],
["section-1.html", "1 环境搭建 1.1 计算平台选择 1.2 基础环境搭建 1.3 依赖工具配置", " 1 环境搭建 在这一章节，介绍流程搭建所需的服务器配置条件，经过比较，AWS是比较好的选择，所以暂时以AWS为例来介绍。其他平台原理类似。 1.1 计算平台选择 研究机构和大学一般会有自己的计算平台，具体的维护依赖管理人员，就我目前所在的学校的计算平台，优势是技术支持比较方便，有什么问题发个邮件或者可以当面交流，但是缺点也很多，比如稳定性不好，经常隔几周就发生一次无预警任务丢失，价格比较贵，计算能力有限，任务容易受其他用户的进程干扰。 一些商业服务商提供的计算平台更可靠划算一些。比较好的是亚马逊和谷歌。优点是数据传输更快，稳定，可选配置多样，但是缺点也很突出，没人帮你配置环境，需要自己配置。 1.1.1 服务商 AWS的服务器挺好。 1.1.2 计算服务器 EC2。有4种形式：On-Demand, Spot instances, Reserved Instances, Dedicated Hosts。其中主要用On-Demand（长期任务）和Spot instances（短期任务）。 这里有详细的配置和报价：https://aws.amazon.com/ec2/pricing/on-demand/ 根据计算需求进行选择。Spot instances会比On-Demand便宜80%左右。但是Spot instances会不定时收回服务器，越高配置的收回越频繁。收回会造成数据丢失。 1.1.3 储存服务器 S3。用于数据备份和共享。将s3挂载到服务器上，对运算结果进行备份。还可以搭配亚马逊的SFTP（https://us-east-2.console.aws.amazon.com/transfer/）建立更稳定的数据传输。 1.2 基础环境搭建 除了系统基础环境，单细胞转录组分析还需要用到一些软件和数据库，这一部分主要介绍环境的搭建。 1.2.1 基础系统工具 后续的一些分析工具的安装需要基于以下工具，本例中，我们基于Amazon Linux AMI 2018.03.0.20181129 x86_64 HVM 版本，这个版本的软件安装主要用yum，不是apt-get。 yum -y install automake fuse fuse-devel gcc-c++ git libcurl-devel libxml2-devel make openssl-devel libpng-devel xfsprogs-devel curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py; python get-pip.py; pip install umap-learn 1.2.2 磁盘挂载 sudo fdisk -l sudo mkdir /mnt/hdd fdisk /dev/xvdba # n w sudo mkfs.xfs -f /dev/xvdba sudo mount -t xfs /dev/xvdba /mnt/hdd df -lh 1.2.3 储存服务器挂载 git clone https://github.com/s3fs-fuse/s3fs-fuse.git cd s3fs-fuse/ ./autogen.sh ./configure make sudo make install s3fs sudo vim /etc/passwd-s3fs sudo chmod 640 /etc/passwd-s3fs sudo mkdir /mnt/s3 sudo /usr/local/bin/s3fs [bucketname] /mnt/s3/ sudo ls /mnt/s3 1.3 依赖工具配置 1.3.1 分析工具 Cell Ranger https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest wget -O cellranger-3.0.2.tar.gz &quot;http://cf.10xgenomics.com/releases/cell-exp/cellranger-3.0.2.tar.gz?Expires=*&quot; tar -xzvf cellranger-2.2.0.tar.gz echo &quot;export PATH=/home/ec2-user/Tools/SingleCell/CellRanger2.2/cellranger-2.2.0:$PATH&quot; &gt;&gt; ~/.bashrc source ~/.bashrc Seurat sudo yum install R install.packages(&quot;png&quot;) source(&quot;https://bioconductor.org/biocLite.R&quot;) BiocInstaller::biocLite(&quot;edgeR&quot;) install.packages(&quot;dbscan&quot;) install.packages(&quot;doParallel&quot;) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;UCSF-TI/fake-hdf5r&quot;) install.packages(&quot;Seurat&quot;) 1.3.2 数据库 "],
["section-2.html", "2 原始数据到表达矩阵 2.1 参考数据库构建 2.2 原始数据格式 2.3 基因表达定量 2.4 多文库合并", " 2 原始数据到表达矩阵 在这一章节，我们对10x genomics的下机原始数据fastq文件进行初步处理，使用Cell Ranger套件完成表达矩阵的计数。 2.1 参考数据库构建 这一步只做一次就够了，花不了很多时间。 2.1.1 单细胞参考数据库 ##download ref gtf file wget http://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-mm10-3.0.0.tar.gz ## make custom ref gtf file cellranger mkref --genome=GRCh38-1.2.0 --fasta=refdata-cellranger-GRCh38-1.2.0/fasta/genome.fa --genes=GRCh38-1.2.0.gtf 2.1.2 单细胞核参考数据库 ##download ref gtf file wget http://cf.10xgenomics.com/supp/cell-exp/refdata-cellranger-mm10-3.0.0.tar.gz ## create pre-mRNA GTF awk &#39;BEGIN{FS=&quot;\\t&quot;; OFS=&quot;\\t&quot;} $3 == &quot;transcript&quot;{ $3=&quot;exon&quot;; print}&#39; refdata-cellranger-GRCh38-1.2.0/genes/genes.gtf &gt; GRCh38-1.2.0.premrna.gtf ## make custom ref gtf file cellranger mkref --genome=GRCh38-1.2.0_premrna --fasta=refdata-cellranger-GRCh38-1.2.0/fasta/genome.fa --genes=GRCh38-1.2.0.premrna.gtf 2.1.3 数据库编辑 主要是向基因组序列文件和注释文件添加需要的基因。 2.2 原始数据格式 程序对格式敏感，需要遵循规则，不然容易跑不下去。 2.2.1 原始数据文件名规则 原始数据的格式是*，按格式写可以把多个Line的同一文库一起分析。 2.2.2 表达矩阵格式 2.2.3 标签列表格式 2.2.4 基因列表格式 2.3 基因表达定量 这一步非常消耗时间，之前做过比较，后续补充。 ## cellranger count Cellranger count --transcriptome=./cellranger-1.2.0/refdata-cellranger-m m10-premrna/ --fastqs=./ --id=ID --nopreflight --jobmode=local --localcores=12 --localmem=200 2.4 多文库合并 aggr cellranger aggr --id=AGG123 \\ --csv=AGG123_libraries.csv \\ --normalize=none "],
["section-3.html", "3 表达矩阵到聚类 3.1 加载数据 3.2 数据质量控制 3.3 数据矫正 3.4 细胞聚类 3.5 细胞类型注释 3.6 表达差异分析", " 3 表达矩阵到聚类 在这一章节，我们基于表达矩阵寻找细胞类型，这一步是分析的关键。 3.1 加载数据 library(Seurat) library(dplyr) library(Matrix) library(&quot;edgeR&quot;) library(dbscan) library(ggplot2) library(RColorBrewer) library(doParallel) library(useful) library(umapr) registerDoParallel(cores=8) #load data data=Read10X(&quot;../filtered_gene_bc_matrices/refdata-cellranger-mm10-1.2.0-coding/&quot;) 3.2 数据质量控制 # calculate size dense.size &lt;- object.size(as.matrix(data)) dense.size sparse.size &lt;- object.size(data) sparse.size dense.size/sparse.size # filter out cell &lt; 10, genes &lt; 200 pbmc=CreateSeuratObject(raw.data=data, min.cells = 10, min.genes = 200,project = &quot;10X&quot;) ### Log Normalize pbmc &lt;- NormalizeData(object = pbmc, normalization.method = &quot;LogNormalize&quot;,scale.factor = 10000) ### calculate mito genes precent mito.genes &lt;- grep(&quot;^mt-&quot;, rownames(pbmc@data), value = T) Rpl.genes &lt;- grep(&quot;^Rpl&quot;, rownames(pbmc@data), value = T) Mrpl.genes &lt;- grep(&quot;^Mrpl&quot;, rownames(pbmc@data), value = T) Rps.genes &lt;- grep(&quot;^Rps&quot;, rownames(pbmc@data), value = T) Mrps.genes &lt;- grep(&quot;^Mrps&quot;, rownames(pbmc@data), value = T) percent.mito &lt;-colSums(expm1(pbmc@data[c(mito.genes),]))/colSums(expm1(pbmc@data)) percent.ribo &lt;- colSums(expm1(pbmc@data[c(Rpl.genes, Mrpl.genes, Rps.genes,Mrps.genes), ]))/colSums(expm1(pbmc@data)) pbmc &lt;- AddMetaData(pbmc, percent.mito, &quot;percent.mito&quot;) pbmc &lt;- AddMetaData(pbmc, percent.mito, &quot;percent.ribo&quot;) ### filter out cell with genes &lt; 200, cell with mito gene percent &gt; 50% pbmc &lt;- FilterCells(object = pbmc, subset.names = c(&quot;nGene&quot;,&quot;percent.mito&quot;), low.thresholds = c(200, -Inf), high.thresholds = c(3000,0.5)) ### filter out gene pbmc &lt;- FindVariableGenes(object = pbmc, mean.function = ExpMean,dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3,y.cutoff = 0.5,do.plot = FALSE) 3.3 数据矫正 3.3.1 UMI 3.3.2 regressing out UMI pbmc &lt;- ScaleData(object = pbmc, vars.to.regress = c(“nUMI”)) 3.3.3 批次效应 3.3.4 doublet 3.4 细胞聚类 3.4.1 初步聚类 pbmc &lt;- RunPCA(pbmc, pc.genes = pbmc@var.genes, do.print = TRUE, pcs.print = 5, genes.print = 5, pcs.compute = 30) pbmc &lt;- ProjectPCA(pbmc) PrintPCA(pbmc, pcs.print = 1:5, genes.print = 5, use.full = TRUE) pdf(&quot;vizPCA.pdf&quot;) VizPCA(pbmc, 1:2) dev.off() pdf(&quot;PCA.pdf&quot;) PCAPlot(pbmc, 1, 2) dev.off() pbmc &lt;- FindClusters(pbmc, dims.use = 1:20, resolution = 1, print.output = 0, save.SNN = T) pbmc &lt;- RunTSNE(pbmc, dims.use = 1:20, do.fast = T) pbmc=RunUMAP(pbmc, dims.use = 1:20) pdf(&quot;umap_pc20_res1.pdf&quot;) DimPlot(object=pbmc, reduction.use = &quot;umap&quot;, do.return = TRUE, vector.friendly = TRUE, pt.size = 0.1,no.legend = F, do.label = T,label.size=8) + ggtitle(&quot;UMAP&quot;) + theme(plot.title = element_text(hjust = 0.5)) dev.off() 3.4.2 聚类合并 for(j in 0:15){ n=table(pbmc@ident) ident=j n[names(n) %in% c(0:ident)]=0 n=n[-1] o=n[n&gt;0] ident2=names(o[1]) bim &lt;- FindMarkers(pbmc, ident.1 = ident, ident.2 =ident2, only.pos = F, test.use = &quot;bimod&quot;) deg=bim[bim$p_val_adj &lt; 0.01,] deg1=deg[abs(deg$avg_logFC) &gt;= 1,] degs=dim(deg) degs1=dim(deg1) for(i in c(names(o[-1]))){ bim &lt;- FindMarkers(pbmc, ident.1 = ident,ident.2 = i, only.pos = F, test.use = &quot;bimod&quot;) deg=bim[bim$p_val_adj &lt; 0.01,] deg1=deg[abs(deg$avg_logFC) &gt;= 1,] degs=cbind(degs,dim(deg)) degs1=cbind(degs1,dim(deg1)) } print(degs1) } pbmc@meta.data$res.1[pbmc@meta.data$res.1 %in% c(1, 2, 4, 5, 6, 7)]=0 3.5 细胞类型注释 3.5.1 组织特异表达基因参考 3.5.2 细胞类群标志基因识别 3.5.3 细胞类型注释 3.6 表达差异分析 3.6.1 和Bulk比 3.6.2 和对照比 "],
["section-4.html", "4 假时间序列和向量分析 4.1 假时间序列分析 4.2 细胞向量分析", " 4 假时间序列和向量分析 在这一章节，包括了一些常规之外的花式分析。 4.1 假时间序列分析 load(&quot;../seurat_after_tSNE.Robj&quot;) set.seed(100);random=NULL;for (subcluster_n in seq(dim(table(pbmc@meta.data$res.0.5))+3)-1){if (subcluster_n %in% c(1,4,7)){next};id=paste(&#39;^&#39;,subcluster_n,&#39;$&#39;, sep = &quot;&quot;);location_tmp=which(grepl(id, pbmc@meta.data$res.0.5));random_tmp=sample(length(location_tmp),min(table(pbmc@meta.data$res.0.5)));random=c(random,location_tmp[random_tmp])} pbmc@data=pbmc@data[,random] pbmc@meta.data=pbmc@meta.data[random,] pbmc@cell.names=pbmc@cell.names[random] batch &lt;- unlist(lapply(colnames(pbmc@data), function(x) strsplit(x,&quot;-&quot;)[[1]][2])) pbmc@meta.data$dbscan=batch x=pbmc@raw.data[rownames(pbmc@raw.data) %in% rownames(pbmc@data), colnames(pbmc@raw.data) %in% colnames(pbmc@data)] target=x[,colnames(x) %in% rownames(pbmc@meta.data)] target=as.matrix(t(target)) name=merge(pbmc@meta.data, target, by=&quot;row.names&quot;) rownames(name)=name$Row.names name=name[,-1] pbmc@meta.data=name[,1:7] name=name[,-1:-7] target=t(name) gene &lt;- read.delim(&quot;genes.tsv&quot;, header=F) colnames(gene)=c(&quot;ID&quot;, &quot;gene_short_name&quot;) g=as.data.frame(rownames(x)) rownames(g)=rownames(x) colnames(g)=c(&quot;gene_short_name&quot;) library(monocle) pd &lt;- new(&quot;AnnotatedDataFrame&quot;, data = pbmc@meta.data) fd &lt;- new(&quot;AnnotatedDataFrame&quot;, data = g) HSMM &lt;- newCellDataSet(as.matrix(target), phenoData = pd, featureData = fd, expressionFamily=negbinomial.size()) HSMM &lt;- estimateSizeFactors(HSMM) HSMM &lt;- estimateDispersions(HSMM) HSMM &lt;- detectGenes(HSMM, min_expr = 0.1) print(head(fData(HSMM))) expressed_genes &lt;- row.names(subset(fData(HSMM), num_cells_expressed &gt;= 10)) disp_table &lt;- dispersionTable(HSMM) ordering_genes &lt;- subset(disp_table, mean_expression &gt;= 0.05 &amp; dispersion_empirical &gt;= 2 * dispersion_fit)$gene_id HSMM &lt;- setOrderingFilter(HSMM, ordering_genes) pdf(&quot;ordering_genes.pdf&quot;) plot_ordering_genes(HSMM) dev.off() HSMM &lt;- reduceDimension(HSMM, max_components=2) HSMM &lt;- orderCells(HSMM, reverse=FALSE) pdf(&quot;ordering_cells_batch.pdf&quot;) plot_cell_trajectory(HSMM, color_by=&quot;dbscan&quot;, cell_size=1) #+ facet_wrap(~dbscan, nrow = 2) dev.off() pdf(&quot;ordering_cells_batch_2.pdf&quot;) plot_cell_trajectory(HSMM, color_by=&quot;dbscan&quot;, cell_size=1) + facet_wrap(~dbscan, nrow = 2) dev.off() pdf(&quot;ordering_cells_cluster_pseudotime.pdf&quot;) plot_cell_trajectory(HSMM, color_by=&quot;Pseudotime&quot;, cell_size=1) dev.off() pdf(&quot;ordering_cells_cluster.pdf&quot;) plot_cell_trajectory(HSMM, color_by=&quot;res.0.5&quot;, cell_size=1) #+ facet_wrap(~dbscan, nrow = 2) dev.off() pdf(&quot;ordering_cells_cluster_2.pdf&quot;) plot_cell_trajectory(HSMM, color_by=&quot;res.0.5&quot;, cell_size=1) + facet_wrap(~dbscan, nrow = 2) dev.off() 4.2 细胞向量分析 "],
["section-5.html", "5 参考文献", " 5 参考文献 "]
]
